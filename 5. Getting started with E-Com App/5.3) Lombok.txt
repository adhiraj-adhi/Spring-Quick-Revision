(5.3) Lombok:
===============

=> Not the island of Indonesia (ðŸ˜‚), but the Project Lombok.
=> Official website: https://projectlombok.org/

------------------------
=> Introduction:
------------------------
(i) Project Lombok is a Java library that automatically plugs into our editor and build tools, spicing up 
our Java.
(ii) It reduces the amount of repetitive code amd increases the readability.
(ii) Never write another getter or equals method again, with one annotation our class has a fully featured 
builder, Automate our logging variables, and much more.

(iv) For instance in our POJO class, we create getter and setter methods, toString() method, or hashCode() 
methods. These can be avoided by using Lombok.

----------------------------
=> Some of the annotations:
----------------------------
(i) @Getter/@Setter: 
-> Generate getter and setter methods. The generated getter/setter method will be 
public unless we explicitly specify an AccessLevel. Legal access levels are PUBLIC, PROTECTED, PACKAGE, 
and PRIVATE.
-> Example:
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;

public class GetterSetterExample {
  @Getter @Setter private int age = 10;
  @Setter(AccessLevel.PROTECTED) private String name;
}

-> Equivaled Vanilla Java code for above example:
publicÂ classÂ GetterSetterExampleÂ {
  private int age = 10;
Â Â privateÂ StringÂ name;
Â Â publicÂ intÂ getAge()Â {
Â Â Â Â returnÂ age;
Â Â }
Â Â publicÂ voidÂ setAge(intÂ age)Â {
Â Â Â Â this.ageÂ =Â age;
Â Â }

Â Â protectedÂ voidÂ setName(StringÂ name)Â {
Â Â Â Â this.nameÂ =Â name;
Â Â }
}

-> We can also put a @Getter and/or @Setter annotation on a class. In that case, it's as if we annotate all 
the non-static fields in that class with the annotation.
-> We can always manually disable getter/setter generation for any field by using the special AccessLevel.NONE 
access level.

(ii) @ToString -> Generates toString() method
(iii) @EqualsAndHashCode -> Generates hashCode and equals implementation from the fields of our object.

(iv) @NoArgsConstructor, @RequiredArgsConstructor, and @AllArgsConstructor
-> What is @RequiredArgsConstructor?
It is used to generate constructor for all the non-initialized fields and fields that are marked as @NonNull
that aren't initialized where they are declared.
-> The order of the parameter matches the order in which the fields appear in our class.

(v) @Data ->  @ToString + @EqualsAndHashCode + @Getter on all fields + @Setter on all the non-final fields 
+ @RequiredArgsConstructor

(vi) @Value -> Immutable variant of @Data; i.e. all fields are made private and final by default, and 
setters are not generated. The class itself is also made final by default, because immutability is not 
something that can be forced onto a subclass. Like @Data, useful toString(), equals() and hashCode() 
methods are also generated, each field gets a getter method, and a constructor that covers every argument 
(except final fields that are initialized in the field declaration) is also generated.

(vii) @NonNull -> We can use @NonNull on a record component, or a parameter of a method or constructor. 
This will cause to lombok generate a null-check statement for us.
-> Example:
importÂ lombok.NonNull;

publicÂ classÂ NonNullExampleÂ extendsÂ SomethingÂ {
Â Â privateÂ StringÂ name;
Â Â 
Â Â publicÂ NonNullExample(@NonNullÂ PersonÂ person)Â {
Â Â Â Â super("Hello");
Â Â Â Â this.nameÂ =Â person.getName();
Â Â }
}

-> Equivaled Vanilla Java code for above example:
importÂ lombok.NonNull;

publicÂ classÂ NonNullExampleÂ extendsÂ SomethingÂ {
Â Â privateÂ StringÂ name;
Â Â 
Â Â publicÂ NonNullExample(@NonNullÂ PersonÂ person)Â {
Â Â Â Â super("Hello");
Â Â Â Â ifÂ (personÂ ==Â null)Â {
Â Â Â Â Â Â throwÂ newÂ NullPointerException("personÂ isÂ markedÂ non-nullÂ butÂ isÂ null");
Â Â Â Â }
Â Â Â Â this.nameÂ =Â person.getName();
Â Â }
}

(vii) @Cleanup: Automatic resource management: Call our close() methods safely with no hassle.
-> Example (with Lombok):
importÂ lombok.Cleanup;
importÂ java.io.*;

publicÂ classÂ CleanupExampleÂ {
Â Â publicÂ staticÂ voidÂ main(String[]Â args)Â throwsÂ IOExceptionÂ {
Â Â Â Â @CleanupÂ InputStreamÂ inÂ =Â newÂ FileInputStream(args[0]);
Â Â Â Â @CleanupÂ OutputStreamÂ outÂ =Â newÂ FileOutputStream(args[1]);
Â Â Â Â byte[]Â bÂ =Â newÂ byte[10000];
Â Â Â Â whileÂ (true)Â {
Â Â Â Â Â Â intÂ rÂ =Â in.read(b);
Â Â Â Â Â Â ifÂ (rÂ ==Â -1)Â break;
Â Â Â Â Â Â out.write(b,Â 0,Â r);
Â Â Â Â }
Â Â }
}

-> Example (without Lombok i.e. Vanilla Java):
importÂ lombok.Cleanup;
importÂ java.io.*;

publicÂ classÂ CleanupExampleÂ {
Â Â publicÂ staticÂ voidÂ main(String[]Â args)Â throwsÂ IOExceptionÂ {
Â Â Â Â @CleanupÂ InputStreamÂ inÂ =Â newÂ FileInputStream(args[0]);
Â Â Â Â @CleanupÂ OutputStreamÂ outÂ =Â newÂ FileOutputStream(args[1]);
Â Â Â Â byte[]Â bÂ =Â newÂ byte[10000];
Â Â Â Â whileÂ (true)Â {
Â Â Â Â Â Â intÂ rÂ =Â in.read(b);
Â Â Â Â Â Â ifÂ (rÂ ==Â -1)Â break;
Â Â Â Â Â Â out.write(b,Â 0,Â r);
Â Â Â Â }
Â Â }
}

(ix) @Builder

---------------------------------------------------------
=> To use Lombok in Intellij we need to do two things:
---------------------------------------------------------
(i) Settings -> Plugins -> Install Lombok
(ii) Settings -> Build Execution, Deployment -> Compiler -> Annotation Processors -> Enable annotation 
processing

---------------------------------------------------------
=> To use Lombok in Eclipse we need to do two things:
---------------------------------------------------------
(i) Download the Lombok JAR file and double click on it. Make sure that Eclipse IDE is checked in IDE 
section and thats all.
(ii) Enable Annotation Processing (if needed):
Go to Window > Preferences > Java > Compiler > Annotation Processing -> Ensure Enable Annotation Processing 
is checked.

----------------------
=> Lombok in Action:
----------------------
(i) We have to add the Lombok dependency in our project. For that we can visit the SpringInitializr website,
Select Maven, Java, Version of SpringBoot same as project, Jar Packaging, and then add lombok dependency.
Then finally cut the dependency from pom.xml file and paste it in our project's pom.xml file.

(ii) Now our Category POJO class will look like:
package com.ecom.project.model;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity(name="categories")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Category {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long categoryId;
	private String categoryName;
}
